options {
STATIC=false;
IGNORE_CASE = true;
}


PARSER_BEGIN(SchemaParser)

package com.github.lindenb.fastorm;

import java.util.*;
import java.math.BigInteger;
import java.util.ArrayList;
import java.io.*;
import org.apache.velocity.Template;
import org.apache.velocity.VelocityContext;
import org.apache.velocity.app.Velocity;
import org.apache.velocity.app.VelocityEngine;

    
@SuppressWarnings(value={"unchecked","unused"})
@javax.annotation.Generated(value="schemaParser")
public class SchemaParser
{
private List<OntClass> structures=new ArrayList<OntClass>();


public class OntNode
    {
    String name;
    
	public String getName()
		{
		return name;
		}
	public String getJavaName()
		{
		return getName().substring(0,1).toUpperCase()+getName().substring(1);
		}
	public String toString()
		{
		return getName();
		}

    }

public class OntClass
    extends OntNode
    {
    List<OntMethod> methods=new ArrayList<OntMethod>();

    }

public class OntMethod
    extends OntNode
    {
    ArgumentList arguments=new ArgumentList();
    OntClass owner;
    DataType retType;
    }

public class GetterMethod
    extends OntMethod
    {
    }

public class StaticMethod
    extends OntMethod
    {

    }

public class SQLMethod
    extends OntMethod
    {
    ArgumentList arguments=new ArgumentList();
    }


public class DataType
    {
    public boolean isPrimitive()
    	{
    	return false;
    	}
    
    public boolean isList()
    	{
    	return false;
    	}
    	
    public boolean isUserType()
    	{
    	return false;
    	}
    }

public class SimpleType extends DataType
    {
    }

public class PrimitiveType extends SimpleType
    {
    Class<?> clazz;
    boolean nillable;
    
    PrimitiveType(Class<?> clazz,boolean nillable)
    	{
    	this.clazz=clazz;
    	this.nillable=nillable;
    	}
    
    public Class<?> getDataClass()
    	{
    	return this.clazz;
    	}
    	
    public boolean isNillable()
    	{
    	return this.nillable;
    	}
    
    @Override
    public boolean isPrimitive()
    	{
    	return true;
    	}
     @Override
    public String toString()
    	{
    	return getDataClass().toString();
    	}
    }

public class UserType extends SimpleType
    {
    String name;
    public UserType(String name)
    	{
    	this.name=name;
    	}
    
    public String getName()
    	{
    	return this.name;
    	}
    
    
    @Override
    public boolean isUserType()
    	{
    	return false;
    	}    	

    @Override
    public String toString()
    	{
    	return getName();
    	}

    }

public class ListOfType extends DataType
    {
    DataType elementType;
    
    
    public DataType getElementType()
    	{
    	return this.elementType;
    	}
    
     public boolean isList()
    	{
    	return true;
    	}
    
    @Override
    public String toString()
    	{
    	return "List<"+getElementType()+">";
    	}
    }


public class WrapType extends DataType
	{
	String name=null;
	ArgumentList arguments=new ArgumentList();
	
	public String getName()
		{
		return this.name;
		}
	public ArgumentList getFields()
		{
		return this.arguments;
		}
	
	@Override
	 public String toString()
	    	{
	    	return getName().toString();
	    	}
	}

public class ArgumentList implements Iterable<Argument>
	{
	List<Argument> array=new ArrayList<Argument>();
	
	public List<Argument> getArguments()
		{
		return this.array;
		}
	public boolean isEmpty()
		{
		return getArguments().isEmpty();
		}
	public void add(Argument arg)
		{
		this.getArguments().add(arg);
		}
	
	@Override
	public Iterator<Argument> iterator()
		{
		return this.getArguments().iterator();
		}
	}

public class Argument
    {
    String name;
    SimpleType type;
    
    public String getName()
		{
		return this.name;
		}
	
    public SimpleType getType()
		{
		return this.type;
		}
    
    @Override
    public String toString()
	    	{
	    	return getName()+" "+getType();
	    	}
    }

private String mainClass=null;
private String destPackage=null;
private File destDir=null;

public static void main(String args[]) throws Exception
	{
	String mainClass="GeneratedORM";
	File destDir=null;
	String destPackage="generated";
	int optind=0;

	while(optind< args.length)
		{
		if(args[optind].equals("-h"))
			{
			System.out.println("Options:");
			System.out.println("-C (main-class)");
			System.out.println("-p (package)");
			System.out.println("-D (dest. directory)");
			return;
			}
		else if(args[optind].equals("-C") && optind+1< args.length)
			{
			mainClass = args[++optind];
			if(!mainClass.matches("[A-Z][a-z0-9]+"))
				{
				System.err.println("Bad name for main class "+mainClass);
				System.exit(-1);
				}
			}
		else if(args[optind].equals("-D") && optind+1< args.length)
			{
			destDir = new File(args[++optind]);
			}
		else if(args[optind].equals("-p") && optind+1< args.length)
			{
			destPackage = args[++optind];
			if(!destPackage.matches("[a-zA-Z_][A-Z_a-z0-9]+(\\.[a-zA-Z_][A-Z_a-z0-9]+)*"))
				{
				System.err.println("Bad name for package "+destPackage);
				System.exit(-1);
				}
			}

		else if(args[optind].equals("--"))
			{
			++optind;
			break;
			}
		else if(args[optind].startsWith("-"))
			{
			System.err.println("Unknown option "+args[optind]);
			System.exit(-1);
			}
		else
			{
			break;
			}
		++optind;
		}
	FileInputStream fin=null;
	SchemaParser app=null;
	if(optind==args.length)
		{
		app=new SchemaParser(System.in);
		}
	else if(optind+1==args.length)
		{
		fin=new FileInputStream(args[optind++]);
		app=new SchemaParser(fin);
		}
	else
		{
		System.err.println("illegal number of args");
		System.exit(-1);
		}
	

	app.structures=app.input();
	
	if(fin!=null) fin.close();
	
	app.mainClass=mainClass;
	app.destDir=destDir;
	app.destPackage=destPackage;
	app.input();
	
	if(fin!=null) fin.close();
	if(app.structures.isEmpty())
		{
		System.err.println("empty input");
		System.exit(-1);
		}
	app.generateCode();	

	}
private void generateCode() throws Exception
	{
	if(destDir!=null && !destDir.exists())
		{
		throw new IOException("output directory doesn't exists");
		}
	
	Properties props = new Properties();
	props.put(Velocity.RESOURCE_LOADER, "class");
	props.put("class.resource.loader.class",
		"org.apache.velocity.runtime.resource.loader.ClasspathResourceLoader"
		);
		
	
	VelocityEngine ve = new VelocityEngine();
	ve.init(props);
	
	VelocityContext ctx=new VelocityContext();
		
	ctx.put("now",new java.sql.Timestamp(System.currentTimeMillis()));
	ctx.put("classes",this.structures);
	ctx.put("mainClass",this.mainClass);
	if(destPackage!=null) ctx.put("package",this.destPackage);
		
	Template template= ve.getTemplate("/velocity/model.vm");
	generateCode(ve,ctx,template,mainClass+".java");
	
	template= ve.getTemplate("/velocity/factory.vm");
	generateCode(ve,ctx,template,mainClass+"Factory.java");
	
	
	template= ve.getTemplate("/velocity/interface.vm");
	for(OntClass C:  this.structures)
		{
		ctx.put("ontClass",C);
		generateCode(ve,ctx,template,C.getJavaName()+".java");
		}
	}

private void generateCode(
	VelocityEngine ve,
	VelocityContext ctx,
	Template template,
	String baseFile
	) throws Exception
	{
	File dir=new File(this.destDir,this.destPackage.replace(".",File.pathSeparator));
	dir.mkdirs();
	File fout=new File(dir,baseFile);
	System.out.println("[Creating]"+fout);
	PrintWriter out=new PrintWriter(fout);
	template.merge(ctx, out);
	out.flush();
	out.close();
	}

}

PARSER_END(SchemaParser)

SKIP :
	{
	" "
	| "\t"
	| "\n"
	| "\r"
	}
	

TOKEN : /* LITERALS */
{
  <CLASS: ("class"|"interface")>
| <PUBLIC: "public">
| <STATIC: "static">
| <COMMA: "," >
| <SEMICOLON: ";" >
| <LPAR: "(" >
| <RPAR: ")" >
| <LBRACK: "{" >
| <RBRACK: "}" >
| <LIST: "List" >
| <LONG: "Long">
| <INTEGER: "Integer">
| <SHORT: "Short">
| <BYTE: "Byte">
| <BOOLEAN: "Boolean">
| <FLOAT: "Float">
| <DOUBLE: "Double">
| <STRING: "String">
| <_long: "long">
| <_int: "int">
| <_short: "short">
| <_byte: "byte">
| <_boolean: "boolean">
| <_float: "float">
| <_double: "double">
| <LT: "<">
| <GT: ">">
| <#LETTER: ["_","a"-"z","A"-"Z"] >
| <#DIGIT: ["0"-"9"] >
| <DOUBLE_QUOTE_LITERAL: "\"" (~["\""])*"\"" >
| <IDENTIFIER: <LETTER> (<LETTER>|<DIGIT>)* >
}

private List<OntClass> input():
		{
		List<OntClass> L;
		}
	{
	L=structures() <EOF>   { return L;}
	}
private List<OntClass> structures():
		{
		OntClass c;
		List<OntClass> L=new ArrayList<OntClass>();
		}
	{
	c=structure(){ L.add(c);} (  c=structure(){ L.add(c);})*
		{
		return L;
		}
	}

private OntClass structure():{OntClass c=new OntClass();OntMethod m;}
	{
	(<PUBLIC>)? <CLASS> c.name=identifier()
	<LBRACK>
	(  m=method(){c.methods.add(m);m.owner=c;} )+
	<RBRACK>
		{
		return c;
		}
	}

private OntMethod method():{OntMethod m=null;DataType retType=null;}
	{
	(<PUBLIC>)? (<STATIC>)?
	retType=anyType() 
	m.name=identifier()
	<LPAR> 
		(m.arguments=arguments())?
	<RPAR> 
		(
		  <SEMICOLON>
		| <LBRACK>
	
		  <RBRACK>
		)
		{
		return m;
		}
		
	}





private ArgumentList arguments():{Argument a;ArgumentList L=new ArgumentList();}
    {
    a=argument() {L.add(a);} ( <COMMA> a=argument() {L.add(a);}  )*
        {
        return L;
        }
    }


private Argument argument():{Argument a=new Argument();}
    {
    a.type=primitiveOrStringType() a.name=identifier()
        {
        return a;
        }
    }


private DataType anyType():{DataType t=null;}
	{
	(
	t=primitiveType() |
	t=boxedType()|
	t=userType() |
	t=listOfType()|
	t=wrapType()
	)   	{
		return t;
		}
	}
	

private WrapType wrapType():{WrapType t=new WrapType();}
	{
	<CLASS> <LBRACK>
	((userType()|primitiveType()|boxedType()) identifier() <SEMICOLON>)*
	<RBRACK>
		{
		return t;
		}
	}

private SimpleType simpleType():{SimpleType t=null;}
	{
	(
	primitiveType() | boxedType()
	)   	{
		return t;
		}
	}
	
	
private PrimitiveType primitiveOrStringType():{PrimitiveType d=null;}
	{
	(d=primitiveType()|  d=stringType() )
		{
		return d;
		}
	}

private PrimitiveType primitiveType():{PrimitiveType p=null;}
    {
    (
      <_long> { p=new PrimitiveType(Long.class,false);}
    | <_int> { p=new PrimitiveType(Integer.class,false);}
    | <_short> { p=new PrimitiveType(Short.class,false);}
    | <_byte> { p=new PrimitiveType(Byte.class,false);}
    | <_boolean> { p=new PrimitiveType(Boolean.class,false);}
    | <_double> { p=new PrimitiveType(Double.class,false);}
    | <_float> { p=new PrimitiveType(Float.class,false);}
    )
    {
    return p;
    }
    }


private PrimitiveType boxedType():{PrimitiveType p=null;}
    {
    (
      <LONG> { p=new PrimitiveType(Long.class,true);}
    | <INTEGER> { p=new PrimitiveType(Integer.class,true);}
    | <SHORT> { p=new PrimitiveType(Short.class,true);}
    | <BYTE> { p=new PrimitiveType(Byte.class,true);}
    | <BOOLEAN> { p=new PrimitiveType(Boolean.class,true);}
    | <DOUBLE> { p=new PrimitiveType(Double.class,true);}
    | <FLOAT> { p=new PrimitiveType(Float.class,true);}
    | p=stringType()
    )
    {
    return p;
    }
    }
    
private ListOfType listOfType():{ListOfType t=new ListOfType();}
	{
	<LIST> <LT> t.elementType=anyType() <GT>
		{
		if(t.elementType.isList()) throw new ParseException("A list-of-list are not allowed.");
		return t;
		}
	}
    
    
private PrimitiveType stringType():{ PrimitiveType t=null;}
	{
	<STRING> { return t;}
	}

private UserType userType():{String s;}
	{
	s=identifier() { return new UserType(s);}
	}


private String identifier():{Token t;}
	{
	t=< IDENTIFIER > {return t.image;}
	}
