#parse("common.vm")
${out.open("${model.name}/README.md")}
Hello World
${out.close()}

#parse("ant01.vm")

#foreach($pack in ${model.packages})

${out.open("${pack.outputDirectory}/package-info.java")}
#parse("package-info.vm")
${out.close()}

#foreach($enumeration in ${pack.enumerations})
#parse("enum01.vm")
#end

#foreach($c in ${pack.eClasses})
#set($ClassName = "#javaName(${c.name})")

${out.open("${model.name}/src/main/java/${c.package.path}/${ClassName}.java")}
package ${c.package.name};



public  interface ${ClassName}
	extends ${model.name}Component
	{
	#foreach($f in ${c.predicates})
	
	/** setter for field ${f.name}*/
	public void #setter(${f})(#fieldType1(${f})  ${f.name});
	
	/** getter for field ${f.name}*/
	public #fieldType1(${f}) #getter(${f})();
	#end
	}

${out.close()}

${out.open("${model.name}/src/main/java/${c.package.path}/impl/${ClassName}Impl.java")}

package ${c.package.name}.impl;
import ${c.package.name}.${ClassName};


/**
 * implementation of ${c.name}
 *
 */
public  class ${ClassName}Impl
	extends Abstract${model.name}Component
	implements ${ClassName}
	{
	/** LOG declaration */
	#LOGDECL()
	
	public ${ClassName}Impl()
		{
		}
	
	#foreach($f in ${c.predicates})
	
	/** declaration of field ${f.name} */
	private #fieldType1(${f}) ${f.name} #if(${f.range.dataRange})#if(${f.representedAsPrimitive})/** TODO SET INIT */#{else}=null#{end}#{else}=null#end;
	
	/** setter for field ${f.name}*/
	@Override
	public void #setter(${f})(#fieldType1(${f})  ${f.name})
		{
		this.${f.name}=${f.name};
		}
	
	/** getter for field ${f.name}*/
	@Override
	public #fieldType1(${f}) #getter(${f})()
		{
		#if(${f.needsList})if(this.${f.name}==null)
			{
			this.${f.name} = new java.util.ArrayList<#fieldType2(${f})>();
			}
		#end
		
		return this.${f.name};
		}
	#end
	
	
	
	@Override
	public String toString()
		{
		StringBuilder b=new StringBuilder(getClass().getName()+"[");
		#foreach($f in ${c.predicates})
		#if(! ${f.needsList})
		
		b.append(" ${f.name}:").append(String.valueOf(this.${f.name}));
		
		#end
		#end
		
		b.append("]");
		return b.toString();
		}
	}
${out.close()}


${out.open("${model.name}/src/main/java/${c.package.path}/swing/${ClassName}TableModel.java")}
package ${c.package.name}.swing;
import ${c.package.name}.${ClassName};

@SuppressWarnings("serial")
public abstract class ${ClassName}TableModel
	extends com.github.lindenb.swing.AbstractGenericTableModel<${ClassName}>
	{
	/** LOG declaration */
	#LOGDECL()
	
	@Override
	public int getColumnCount()
		{
		return 0;
		}
	}

${out.close()}

#end

#end

${out.open("${model.name}/src/main/java/com/github/lindenb/swing/AbstractGenericTableModel.java")}
package  com.github.lindenb.swing;

import java.util.List;
import java.util.Vector;
import javax.swing.table.AbstractTableModel;

@SuppressWarnings("serial")
public abstract class AbstractGenericTableModel<T>
	 extends AbstractTableModel
	{
	/** LOG declaration */
	#LOGDECL()
	
	private List<T> rows=new Vector<T>();
	
	public AbstractGenericTableModel()
		{
		}
	
	public AbstractGenericTableModel(List<T> rows)
		{
		this.rows=new Vector<T>(rows);
		}
	
	@Override
	public abstract Class<?> getColumnClass(int col);
	
	@Override
	public abstract String getColumnName(int col);
	
	public List<T> getRows()
		{
		return rows;
		}
	
	public void setRows(List<T> rows)
		{
		this.rows = new Vector<T>(rows);
		fireTableDataChanged();
		}
	
	public void setElementAt(int row,T o)
		{
		this.rows.set(row, o);
		this.fireTableRowsUpdated(row, row);
		}
	
	public T getElementAt(int i)
		{
		return this.getRows().get(i);
		}
	
	public abstract Object getValueOf(final T o, int col);
	
	@Override
	public final Object getValueAt(int row, int col)
		{
		T rsrc=getElementAt(row);
		return rsrc==null?null:getValueOf(rsrc,col);
		}
	
	public void addElement(T o)
		{
		int n=getRowCount();
		this.rows.add(o);
		fireTableRowsInserted(n, n);
		}		
	
	@Override
	public int getRowCount()
		{
		return rows.size();
		}
	@Override
	public boolean isCellEditable(int arg0, int arg1)
		{
		return false;
		}
	public void clear()
		{
		this.rows.clear();
		fireTableDataChanged();
		}
	}


${out.close()}


public interface #javaName(${model.name})Component
	{
	public #javaName(${model.name}) get#javaName(${model.name})();
	}


public abstract class Abstract#javaName(${model.name})Component
	implements #javaName(${model.name})Component
	{
	private transient #javaName(${model.name}) _owner=null;
	protected Abstract#javaName(${model.name})Component()
		{
		}
	
	public #javaName(${model.name}) get#javaName(${model.name})()
		{
		return this._owner;
		}
	
	public void set#javaName(${model.name})(#javaName(${model.name}) owner)
		{
		this._owner=owner;
		}	
	}

${out.open("${model.name}/src/main/java/com/github/lindenb/${model.name.toLowerCase()}/${model.javaName}Component.java")}
package 

public interface ${model.javaName}Component
	{
	/** return the associated ${model.javaName} */
	public ${model.javaName} get${model.javaName}();
	}
${out.close()}

${out.open("${model.name}/src/main/java/com/github/lindenb/${model.name.toLowerCase()}/ui/tree/${model.javaName}TreeNode.java")}
package com.github.lindenb.${model.name.toLowerCase()}.ui.tree

public class ${model.javaName}TreeNode
	implements javax.swing.tree.TreeNode
	{
	private ${model.javaName} model;
	private java.util.List<javax.swing.tree.TreeNode> children=
		new java.util.Vector<javax.swing.tree.TreeNode>();
	
	public  ${model.javaName}TreeNode( ${model.javaName} model)
		{
		this.model=model;
		#foreach($c in ${pack.eClasses})
		children.add(null);
		#end
		}
		
	protected List<javax.swing.tree.TreeNode> getChildren()
		{
		retunr this.children;
		}
	
	public  ${model.javaName}  get${model.javaName}()
		{
		return this.model;
		}
	
	@Override
	public int 	getChildCount()
		{
		return getChildren().size();
		}
	
	@Override
	public int getIndex(TreeNode node)
		{
		return getChildren().indexOf(node);
		}
		
	@Override
	public TreeNode getChildAt(int childIndex)
		{
		return getChildren().elementAt(childIndex);
		}
			
	@Override
	public final boolean isLeaf()
		{
		return false;
		}
	
	public final TreeNode getParent()
		{
		return null;
		}
	
	@Override
	public String toString()
		{
		return "${model.name}";
		}
	}
${out.close()}


${out.open("${model.name}/src/main/java/com/github/lindenb/${model.name.toLowerCase()}/ui/${model.javaName}Frame.java")}
package com.github.lindenb.${model.name.toLowerCase()}.ui.tree

public class ${model.javaName}TreeNode
	implements javax.swing.tree.TreeNode
	{
	private ${model.javaName} model;
	private java.util.List<javax.swing.tree.TreeNode> children=
		new java.util.Vector<javax.swing.tree.TreeNode>();
	
	public  ${model.javaName}TreeNode( ${model.javaName} model)
		{
		this.model=model;
		#foreach($c in ${pack.eClasses})
		children.add(null);
		#end
		}
		
	protected List<javax.swing.tree.TreeNode> getChildren()
		{
		retunr this.children;
		}
	
	public  ${model.javaName}  get${model.javaName}()
		{
		return this.model;
		}
	
	@Override
	public int 	getChildCount()
		{
		return getChildren().size();
		}
	
	@Override
	public int getIndex(TreeNode node)
		{
		return getChildren().indexOf(node);
		}
		
	@Override
	public TreeNode getChildAt(int childIndex)
		{
		return getChildren().elementAt(childIndex);
		}
			
	@Override
	public final boolean isLeaf()
		{
		return false;
		}
	
	public final TreeNode getParent()
		{
		return null;
		}
	
	@Override
	public String toString()
		{
		return "${model.name}";
		}
	}
${out.close()}

